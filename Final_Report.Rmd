---
title: "Movement of Domestic Cats"
author: "Jennifer Freeman & Jason Pekos"
date: "22/12/2021"
output:
  html_document: default
  pdf_document: default
bibliography: references.bib
---



## Data set

Over 900 domestic cats were tracked with GPS collars from six different countries. The large majority of the cats were from Australia, New Zealand, the United Kingdom and the United States. Their spatial-temporal data was recorded for a range of 1 to 549 days and was retrieved from  [movebank.org](https://movebank.org) [@AU_data][@NZ_data][@UK_data][@US_data]. The metadata consisted of age, sex, neutered/spayed status, and the owner reported number of prey killed. The focus of the study was to understand the spatial context of their movement to assess the ecological impacts of these predators [@Kays].

```{r load, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(move)
library(lubridate) #for dates
library(scales)
library(directlabels)
library(cowplot) #arranging plots
library(ggmap) #get_map()
library(plotly)
library(RColorBrewer)
library(ggthemes) #theme_tufte
library(adehabitatLT) #ltraj - animal trajectories
library(viridis)
library(sf)
library(raster)
library(ggpolypath)
library(ozmaps)
library(stars)
library(osmdata)
library(OpenStreetMap)
#movement data
CatDatAus <- move("PetCatsAus.csv") 
CatDatNZ <- move("PetCatsNZ.csv")  
CatDatUK <- move("PetCatsUK.csv") 
CatDatUS <- move("PetCatsUS.csv")  

#reference data
RefAus <- read.csv("Pet Cats Australia-reference-data.csv")
RefUK <- read.csv("Pet Cats United Kingdom-reference-data.csv")
RefNZ <- read.csv("Pet Cats New Zealand-reference-data.csv")
RefUS <- read.csv("Pet Cats United States-reference-data.csv")


#join movement and reference data
CatDFAus<-(left_join(as.data.frame(CatDatAus), RefAus, by=c("trackId"="animal.id"))
           %>% mutate(Country = "Australia")
)

CatDFUK<-(left_join(as.data.frame(CatDatUK), RefUK, by=c("trackId"="animal.id"))
 %>% mutate(Country = "United Kingdom")
)
CatDFUS<-(left_join(as.data.frame(CatDatUS), RefUS, by=c("trackId"="animal.id"))
 %>% mutate(Country = "United States")
)
CatDFNZ<-(left_join(as.data.frame(CatDatNZ), RefNZ, by=c("trackId"="animal.id"))
 %>% mutate(Country = "New Zealand")
)

#union all data into one 
cats<-union_all(CatDFAus, CatDFNZ)
cats<-union_all(cats, CatDFUK)
cats<-union_all(cats, CatDFUS)

```



```{r day_night,echo=FALSE, message=FALSE}

#day/night distances
day_night <- (cats
         %>% arrange(Country, trackId, timestamp)
         #drop time
         %>% mutate(dy=floor_date(timestamp, "day"),
                    hr = hour(round_date(timestamp, "hour")),
                    diurnal = ifelse((hr < 6 | hr > 18), "Night", "Day"))
         %>% group_by(Country, trackId)
         #distance computed between each successive timestamp
         #each change from "Day" to "Night" will contain distance spillover
         %>% mutate(dist_btw = distHaversine(cbind(location.long, location.lat),cbind(lag(location.long),lag(location.lat))))
         # set first record for each cat to 0 distance
         %>% mutate(dist_btw = if_else(is.na(dist_btw),0,dist_btw))
         %>% ungroup() #do I need to ungroup?
         %>% group_by(Country, trackId, diurnal)
         %>% summarize(Total_diurnal=sum(dist_btw))

)

#number of days each cat is tracked
days_tracked<- (cats
         %>% arrange(Country, trackId, timestamp)
         #drop time
         %>% mutate(dy=floor_date(timestamp, "day"))
         %>% group_by(Country, trackId)
         #number of days each cat is tracked
         %>% summarize(days = n_distinct(dy), .groups="keep")
)

avg_day_night <- (left_join(day_night, days_tracked, by=c("Country"="Country", "trackId"="trackId"))
                  %>% mutate(avg = Total_diurnal/days)
)


ref <- (cats
        %>% dplyr::select(Country, trackId, animal.sex, animal.life.stage, animal.reproductive.condition)
        %>% mutate(animal.life.stage = readr::parse_number(animal.life.stage))
        %>% distinct()
  
)
#drop 0 ages and NAs

total <- (left_join(avg_day_night, ref, by=c("Country"="Country", "trackId"="trackId"))
          %>% filter(!is.na(animal.life.stage), animal.life.stage!=0, animal.sex %in% c('f','m'), avg!=0)
          %>% mutate(animal.sex = if_else(animal.sex == "f","Female","Male"))
          %>% mutate(sex_diurnal = interaction(animal.sex, diurnal))
          #bin less that 1 year as 0, so consistent with all age binning
          %>% mutate(animal.life.stage = ifelse(animal.life.stage<1,0,animal.life.stage))
          %>% mutate(animal.reproductive.condition = case_when(
            animal.reproductive.condition %in% c("Spayed", "Neutered") ~ "Fixed",
            animal.reproductive.condition %in% c("Not Fixed", "Not fixed") ~ "Not Fixed",
            TRUE ~ "Other"
            ))
          %>% filter(animal.reproductive.condition!="Other")
          
  
)

```


```{r NSD, echo=FALSE, message=FALSE,warning=FALSE}
# net squared displacement

#4 year old cats, with time tracked
young <-(cats
         %>% mutate(diff = as_date(deploy.off.date)-as_date(deploy.on.date))
         %>% mutate(age = readr::parse_number(animal.life.stage))
         %>% filter(age ==4)
  
)

#male and female cats tracked for seven days
avg_tracked_male <- (young
            %>% filter(diff==7)
            %>% filter(animal.sex=="m")
)

avg_tracked_female <- (young
                     %>% filter(diff==7)
                     %>% filter(animal.sex=="f")
)


#randomly choose one male and one female
set.seed(100)
rand <- runif(2,1,min(length(unique(avg_tracked_male$trackId)),
                      length(unique(avg_tracked_female$trackId))))
round_rand = round(rand)

female <- unique(avg_tracked_female$trackId)[round_rand[1]]
male <-unique(avg_tracked_male$trackId)[round_rand[2]]


monmon <- CatDatAus[["MonMon"]]
moscow <- CatDatAus[["Moscow"]]

monmon_df <- as(monmon,"data.frame")
moscow_df <- as(moscow,"data.frame")


#net squared displacement
monmon_track <- as(monmon, 'ltraj')
moscow_track <- as(moscow, 'ltraj')

#convert to data frame for plotting
monmon_track_df<-as.data.frame(monmon_track[[1]])
moscow_track_df<-as.data.frame(moscow_track[[1]])

#bounding boxes of cats
box_one = c(bottom = -35.070, top =-35.06233, right  =138.5321 , left  = 138.5239 )
box_two = c(bottom = -35.08307, top =-35.0754, right  =138.5321 , left  = 138.5239 )

#get maps
map_one = get_map(box_one, source="stamen", maptype = "watercolor", zoom=8)
map_two = get_map(box_two, source="stamen", maptype = "watercolor", zoom=8)
```
 
 
```{r time_tracked,echo=FALSE, message=FALSE,warning=FALSE}
#time cats are tracked
cats_diff <- (cats
              #%>% mutate(diff = as_date(deploy.off.date)-as_date(deploy.on.date))
              %>% mutate(Country = factor(Country, levels = c("United States",
                                                              "Australia",
                                                              "New Zealand",
                                                              "United Kingdom"))) 
              #there are cats with the same name in different countries
              %>% mutate(Country_name= paste0(Country,"_",trackId))
              #test
              %>% group_by(Country_name)
              %>% mutate(min_date=min(timestamp))
              %>% mutate(max_date = max(timestamp))
              %>% ungroup()
              #some cats have no deploy date, using minimum timestamp instead
              %>% mutate(deploy.on.date =if_else(is.na(deploy.on.date),
                                          as_date(min_date),
                                          as_date(deploy.on.date)))
              %>% mutate(deploy.off.date =if_else(is.na(deploy.off.date),
                                          as_date(max_date),
                                          as_date(deploy.off.date)))
              %>% mutate(diff = deploy.off.date-deploy.on.date)
              %>%  dplyr::arrange(Country,deploy.on.date)
              %>% mutate(Country_name = forcats::fct_inorder(Country_name))
)

```
 
```{r dBBM,echo=FALSE, message=FALSE,warning=FALSE,results='hide'}
#DBBM Setup 

projectionReal = "+proj=robin" #different map projections for underlying maps. 
projectionGoogle = "+proj=longlat +datum=WGS84" #this is what get_map uses
extReal = 6.5 #extent term in DBBM model
truncator = 0.95 #truncate all possible locations with < n% travel probability 

mollybox = c(bottom = -34.98222, top = -34.97963, left = 138.619, right  = 138.6226) #box for molly plot (if used)
map_molly = get_map(mollybox, source="stamen", maptype = "watercolor", zoom=8)

#get maps
#map_molly = get_map(mollybox, source="stamen", maptype = "watercolor", zoom=9) #get molly map (currently not used)

dfmaker <- function(AusCatName){
  #take any cat and get the corresponding raster as a dataframe, going through dBDDM -> Utilization Distributions -> spdf -> final dataframe, truncated. 
  cat = CatDatAus[[AusCatName]]
  dBB <-  brownian.bridge.dyn(object = spTransform(cat,CRS(projectionReal)),
                                   ext = extReal,
                                   raster = 40,
                                   location.error = 1.5)
  UD <- getVolumeUD(dBB)
  
  UDspdf <- as(UD, "SpatialPixelsDataFrame")
  
  DF <- filter(as.data.frame(UDspdf), layer < truncator)
  
  return(DF)
}


                
#NOTE FOR LATER: EMD doesn't care about time differences! Mention this!
x1 = 138.5
x2 = 138.7
y1 = -35
y2 = -34.9


sf::sf_use_s2(FALSE) #ignore geom meshing error caused by transform + bounding box.

maps = st_transform(ozmaps::abs_ced  %>% filter(NAME %in% c("Adelaide", "Boothby", "Hindmarsh", "Sturt", "Port Adelaide", "Mayo")), crs = projectionReal) #map of Aus cities.

bboxAus = c(x1,y1, x2,y2)

dispWin = st_coordinates(st_transform(st_sfc(st_point(c(x1,y1)), st_point(c(x2,y2)),crs = 4326), crs = projectionReal)) #Bounding box.

                  
q1 <- opq(bbox = bboxAus) %>%
    add_osm_feature(key = 'highway', value = c("motorway", "primary", "trunk", "secondary", "motorway_link", "primary_link", "cycleway"))

cway_AD <- osmdata_sf(q1)


roads = st_transform(cway_AD$osm_lines, projection  = projectionReal)

```

## The Story

### Plot 1

A defining characteristic of animal movement data are when animals are tracked. Often groups of animals are tracked in different time periods. Understanding this information is the first step before movement analysis can be performed. 

The first plot shows the length of time cats were tracked per region. We can immediately draw some useful information. Australia has the largest number of cats that were tracked. The United States had several cats that were tracked for longer than average periods. The cats from New Zealand were tracked in roughly the same time frame as Australia. 

The densities below the plot show a clearer relationship of the time overlap between countries. They also provide more immediate information about the number of cats tracked in a time period versus the line plot which consists of tightly packed lines.

The interactivity allows us to gain more information about individual cats including name, country, date deployed and days tracked. By zooming in and using the tooltip we can find out that the longest cat tracked is from the United States, is named Oscar.L, and was tracked for 549 days starting in November 2014.

```{r Plot_1,echo=FALSE, message=FALSE,warning=FALSE,fig.height=5,fig.width=9,fig.align = 'center'}
FullPlot = (ggplot(cats_diff, aes(x = timestamp, y = Country_name, colour = Country,
                                 text = paste('Name:',trackId,
                                              '<br>Country:',Country,
                                              '<br>Date Deployed:',deploy.on.date,
                                              '<br>Days tracked:',diff)
                                 )
                  )
            # + geom_rect(ymin = 826, ymax = 950,
            #             xmin = -Inf, xmax = Inf, fill="grey98",
            #             alpha=0.5,inherit.aes = FALSE)
            # + geom_rect(ymin = 155, ymax = 387,
            #             xmin = -Inf, xmax = Inf, fill="grey98",
            #             alpha=0.2,inherit.aes = FALSE)
            + geom_line()
            + geom_dl(aes(label=Country,colour=Country),method="smart.grid",size=5)
            + theme_bw()

            + ggtitle("Individual tracking time by Country")
            + labs(x = "Date", y = "Individual Cat Recorded")
            + theme(axis.ticks.y = element_blank(), 
                    axis.text.y  = element_blank(),
                    axis.ticks.x  = element_blank(),
                    axis.text.x  = element_blank(),
                    axis.title.x = element_blank(),
                    panel.grid.major = element_blank(),
                    panel.grid.minor = element_blank(),
                    legend.position=c(0.13,0.3)  
                    )
            + scale_y_discrete(breaks = NULL)
            + scale_colour_manual(values = brewer.pal(4,"Dark2"))
)

DensityPlot = (ggplot(data = cats_diff,
                      aes(text=paste('Country',Country)))
               + geom_density(data = cats_diff, 
                              aes(x = timestamp, y = after_stat(count),
                                  colour = Country,fill=Country),
                              inherit.aes = FALSE, alpha=0.3)
               + theme_tufte()
               + theme(axis.ticks.y = element_blank(), 
                       axis.text.y  = element_blank(),
                       legend.title = element_blank(),
                       legend.position = "none")
               + labs( y = "Density", x="")
               + scale_colour_manual(values = brewer.pal(4,"Dark2"))
               + scale_fill_manual(values = brewer.pal(4,"Dark2"))
)

# fig <- ggplotly(FullPlot, tooltip=c("text"))
# fig

subplot(ggplotly(FullPlot,tooltip=c("text")),
        #DensityPlot,
        ggplotly(DensityPlot,tooltip=c("text")),
        nrows=2,heights=c(0.7, 0.2),shareX=TRUE)

#tooltips for density not passing
#where is legend?
#how to pass y-axis?
#geom_rects not passing
```



### Plot 2

We were interested in determining if there were patterns in cat movement between day and night. Mice are a common prey species of cats and are nocturnal so we might expect to see increased cat movement in the night time hours. Alternatively, homeowners might choose to keep pets indoors overnight so movement may be restricted.

We chose to use average distance traveled to assess differences in day/night behavior. We incorporated age and sex to determine if there was any underlying relationships. 

This plot agrees with the findings in [@Kays] that on average young male cats traveled the furthest. Specifically, young males under 6 years old moved farther than females of the same age group. For cats in the 6-12 range, males on average traveled further at night than females. During the day, there were no noticeable differences in this age group. There were minimal cats over the age of 12 so it is difficult to understand relationships for this age group.

[@Kays] looked at the ten cats in the data set that were not spayed or neutered to evaluate average home range size by sex. Due to the limited number of cats that were not fixed, these cats were not identified in this plot.

```{r Plot_2, echo=FALSE,message=FALSE, fig.height=4,fig.align = 'center',fig.width=10}
#Average distance per day/night with age and sex
g <- (ggplot(total, aes(x=animal.life.stage,y=avg, colour=animal.sex))
 + geom_jitter(alpha=0.2,width=0.3, height=0)
 + geom_smooth(se=F)
 + scale_y_log10(labels = trans_format("log10", math_format(10^.x)))
 + facet_grid(cols = vars(diurnal))
 + scale_shape_manual(values = c(16,4))
 + theme_bw()
 + theme(panel.spacing.x = unit(0,"cm"), legend.position=c(0.92,0.15),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank())
 + xlab("Age")
 + ylab("Average Distance Travelled (m)")
 + labs(colour="")
 + scale_colour_manual(values = c("#D95F02","#7570B3"))
 )
print(g)
```

### Plot 3

To further explore the relationships between the sexes for younger cats, we looked at the net-squared displacement (NSD) and movement tracks for one male cat named Moscow and one female cat named Monmon. These cats were chosen uniformly at random from the data after first narrowing down for 4 year-old cats that were tracked for 7 total days. 

The NSD is the squared "Euclidean distance between the starting location of a movement path and each subsequent location."[@Bastille]. Viewing the NSD over time can help classify common movement behaviours. Given the noisey but flat relationship between NSD over time for Moscow this suggests that he exhibits a sedentary movement pattern [@Bastille]. This can be verified by the track of Moscow that is tightly clustered in one area.

The large distances from home that Monmon travels is typical with nomadic behaviour, however it is difficult to tell if the time spent at these farther distances would characterize true nomad behaviour. In the seven day period there appears to be a pattern to Monmon's movements between staying close to home and travelling farther distances. 

[@Kays] suggests that the consistent food source from cat owners attribute to this sedentary behaviour. The study found that most cats stay within 100m of their home. 

```{r Plot_3, echo=FALSE,message=FALSE,fig.align = 'center',fig.width=7}
#Track of female cat
n1<-(ggmap(map_one)
  + geom_path(data=monmon_df, aes(x=location.long, y=location.lat),colour="#D95F02")
  + theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank())
  + ggtitle("Track of Monmon")
)
#Track of male cat
n2<-(ggmap(map_two)
  + geom_path(data=moscow_df, aes(x=location.long, y=location.lat),colour="#7570B3")
  + theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank())
  + ggtitle("Track of Moscow")
)

#NSD of female cat
n3 <- (ggplot(monmon_track_df, aes(x=date,y=R2n))
       + geom_point(colour="#D95F02")
       + theme_bw()
       + theme(
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          panel.grid.major=element_blank(),
          panel.grid.minor=element_blank())
       + ylab("Net Squared Displacement")
       + xlab("Time (7 days)")
)

#NSD of male cat
n4 <- (ggplot(moscow_track_df, aes(x=date,y=R2n))
       + geom_point(colour="#7570B3")
       + theme_bw()
       + theme(
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          panel.grid.major=element_blank(),
          panel.grid.minor=element_blank())
       + ylab("Net Squared Displacement")
       + xlab("Time (7 days)")
)

#arrange
n<-plot_grid(n3,n1,n4,n2,ncol=2,rel_widths = c(2,1))
print(n)
```


## Plot Four

Drawing straight lines between cats can be useful, but it fails to capture the underlying uncertainty in animal tracking data. To deal with this, we utilize Dynamic Brownian Bridge Models to recover Utilization Distributions, which can more accurately capture the most likely home range of different cats. Along with more accurately answering questions around potential home area, Dynamic Brownian Bridge Models provide an interesting qualitative method for forming hypothesis around animal interaction and predation; although the cats do tend to stick within 100m of their homes, there is plenty of overlapping home range, especially in the southwest of Adelaide. Asking questions about predation in these areas of high overlap could be interesting. 

The Individual plot of MonMon is plotted to give an example of a cat with an interesting (non-circular) utilization distribution.


```{r Plot_4, echo=FALSE,message=FALSE,results='hide', warning=FALSE,fig.keep='all',fig.align = 'center',fig.width=10}


#https://stackoverflow.com/questions/33227182/how-to-set-use-ggplot2-to-map-a-raster



bigplot = ggplot() + #Set up base of plot .
                theme_bw() +
                theme(legend.position = "none") +
                ggtitle("UD - Adelaide Cats") +
                theme(
                      axis.text.x=element_blank(),
                      axis.ticks.x=element_blank(),
                      axis.ticks.y=element_blank(),
                      axis.text.y=element_blank(),
                      panel.grid.major=element_blank(),
                      panel.grid.minor=element_blank()) +
                scale_fill_viridis(option = "magma") +
                geom_sf(data = maps, fill = NA) +
                geom_sf(data = roads) +
                coord_sf(xlim = dispWin[,'X'],
                         ylim = dispWin[,'Y'], 
                         datum = projectionReal,
                         expand = FALSE)


cdf <- as.data.frame(CatDatAus) %>%  #Filter out the problem cats, and the cats too far away
       filter(location.long < x2) %>%
       filter(location.lat < y2) %>%
       filter(location.lat > y1) %>%
       filter(location.long > x1)  %>%
       filter(individual.local.identifier != "Jasmine")%>%
       filter(individual.local.identifier != "Costa") %>%
       filter(individual.local.identifier != "Wally")


min(CatDatAus[["MonMon"]]$location.lat)
names = unique(cdf$individual.local.identifier) 

#https://stackoverflow.com/questions/15987367/how-to-add-layers-in-ggplot-using-a-for-loop
extReal = 20 #used by function (bad programming)
for (name in names) { #using function to call dBBM pipeline for every cat + add to plot.
  print(name)
  bigplot = bigplot + geom_tile(data = dfmaker(name), aes(x = x, y = y, fill = layer, alpha = 0.5))
  ggplot_build(bigplot)
}

smallplot = ggplot() + #plot of just monmon
     #Set up base of plot .
    theme_bw() +
    ggtitle("UD - MonMon") +
    theme(
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.y=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        aspect.ratio=1) +
        scale_fill_viridis(option = "magma") +
        theme(legend.position = "none") +
        #geom_sf(data = roads) +
        #coord_sf(xlim = dispWin[,'X'],ylim = dispWin[,'Y'], datum = projectionReal,expand = FALSE) + 
  geom_tile(data = dfmaker("MonMon"), aes(x = x, y = y, fill = layer, alpha = 0.5)) 


totalplot = plot_grid(bigplot, smallplot,ncol=2,rel_widths = c(2,1))
print(totalplot)

```

## Methods

### Plot 1

The time tracking plot was ordered by country and date the GPS device was first deployed on the cat. When there was no deployed date, the first recorded time stamp for the cat was used. This ordering is visually pleasing, and easily allows the user to assess when cats were tracked for different countries.

The density of cats tracked by country was added to provide a clearer measure of how many cats are tracked within a time period, and how the countries overlap in time periods.

A quantitative colour scale was used for the four countries, and it is consistent across the line and density plots to allow for easy comparison between the two. The tooltip allows the user to focus in on individuals or groups, which provides additional information that would not be possible to display all at once for the whole dataset.

The deployed date uses Cleveland's top hierarchy of position along a common scale. The third hierarchy, length was used to encode the time cats were tracked. It is lower on the hierarchy, however we thought it was more intuitive to view the time cats were tracked. For example, graphing date versus days tracked would create a cloud of points for common tracked times, and it would create more visual load on the reader to understand the relationship. In addition, we would not be able to display the overlapping relationship between cats tracked over the same time range which is important information.

### Plot 2


The data was encoded with the highest Cleveland principle first, position along a common scale. Two visually distinct colours were used to code the sex variable. 

The side-by-side facets allow for easy distance comparison between day and night. The legend was overlayed on the plot to allow for a wider aspect ratio to provide emphasis on the changes by age. 

For cats under 1-year old the age was reported in decimals. To be consistent with the rest of the data set, all cats under one year old were binned in the zero age group.

A LOESS smoother was overlayed on the data to capture potential trends. The data points were included to show the full picture of the data and transparency was used to be able to distinguish the trend line clearly. To prevent dense overlapping of points with the binned age data, a small amount of horizontal jitter was added. The jitter is small enough to still be able to distinguish between ages.



### Plot 3

The NSD plots and movement tracks per animal were displayed side-by-side for easy comparison.
The colours from Plot 2 were reused so the user can associate between colours and coding of the sex variable. Consistent colours were used horizontally so the user can make comparisons between the cats.

The movement tracks were plotted using the same size area so the relative distances can be visually compared. Keeping a consistent scale in the movement tracks did make it difficult to see the details of Moscow's tracks and the graph occupies a lot of empty space, however zooming in on Moscow's track would mislead the reader about relative distances. Although perception of area is lower on the Cleveland hierarchy, it was important to be able to view the spatial tracks to relate to the NSD values. The latitude and longitude data was removed from the axis of the track plots as it did not provide any helpful information.

The exact time scale was removed from the NSD plots as this was not as important to the interpretation of the plots. The axis label indicates each cat was tracked for seven days which is sufficient information for interpretation.


### Plot 4

 dBBM model calls require certain projections, so Robinson Projection was used instead of the more standard Pseudo-Mercator projection that is default in most methods. 
 
 The magma colormap was picked because (1) it is colorblind friendly, (2), it fades to white as probability falls to zero, and (3), it is sequential, not diverging, which is perfect for heatmaps. 
 
Streets, state lines, and the coast are added to the plot to give a sense of scale --- satellite imagery doesn't work well with coordinate transforms, and neither do the dBBM dataframes we pass into 'geom_tile()'. These geoms assume square or rectangular tiles, and projections distort this in a way that ggplot can't understand. Leaving the background as white, while lighter on ink, is significantly less interpretable. 
 


 
## References



